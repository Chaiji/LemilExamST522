{
    "contents" : "\n#' @title Markov Chain Simulator\n#' @export\n#' @return Returns a vector of values corresponding to the stationary probability for each state in the given transition probability matrix.\n#' @usage mc.discrete(p,k,n)\n#' @keywords simulation markov chain transition matrix probability\n#' @description This function takes 3 arguments to simulate the stationary probabilities from a transition probability matrix.\n#' @param p is a transition probability matrix for Markov Chain simulation.\n#' @param k is a single integer number that states which state the simulation starts at.\n#' @param n is a single natural number that decides how many simulation steps is to be done.\n#' @author Nguyen Khanh Le Ho & Emil H. Andersen \\cr\n#' Department of Mathematics and Computer Science (IMADA) \\cr\n#' University of Southern Denmark, Denmark \\cr\n#' \\email{emila14@student.sdu.dk} \\cr\n#' \\email{ngho14@student.sdu.dk} \\cr\n#' @examples\n#' mc.discrete(matrix(c(0,0,0,0.4,0.7,0.5,0.6,0.3,0.5),nrow=3,ncol=3),1,100)\n\nmc.discrete <- function(p,k,n){\n  #------------------------------------Error Handler:--------------------------------------------#\n  # ---------------------------------------------------------------------------------------------#\n  # p is a transition probability matrix                                                         #\n  # k is an integer indicating the initial state of the chain                                    #\n  # n is a natural number indicating the number of simulated steps                               #\n  #----------------------------------------------------------------------------------------------#\n  #p is a matrix with ncol=nrow\n  if(is.list(p) || !is.numeric(p) || !is.matrix(p) || is.vector(p)){\n    stop(\"The given data 'p' must be a numerical matrix.\")\n  } else if(dim(p)[1] != dim(p)[2]){\n    stop(\"The given data 'p' must have the same number of columns and rows.\")\n  } else if(sum(p) != dim(p)[1]){\n    stop(\"The given data 'p' must have summed probability 1 in every row.\")\n  }\n  if(is.matrix(k) || is.list(k) || length(k)!=1){ #Check that k is a single value\n    stop(\"'k' has to be a positive integer; length=1, non-list, non-matrix\")\n  } else if(!is.numeric(k)){ #checks if n is a number\n    stop(\"'k' has to be a positive integer\")\n  } else if(k < 1 || n != round(n) || k > dim(p)[2]){ #checks if k is a natural number inside the transition probability matrix\n    stop(\"'k' has to be a positive integer between 1 and the width/height of the transition probability matrix\")\n  }\n  if(is.matrix(n) || is.list(n) || length(n)!=1){ #Check that n is a single value\n    stop(\"'n' has to be a positive integer; length=1, non-list, non-matrix\")\n  } else if(!is.numeric(n)){ #checks if n is a number\n    stop(\"'n' has to be a positive integer\")\n  } else if(n < 1 || n != round(n)){ #checks if n is a natural number\n    stop(\"'n' has to be a positive integer\")\n  }\n  #---------------------------------------End Error Handler--------------------------------------#\n  width <- dim(p)[2] #Lets us know what the highest number to expect.\n  road <- rep(0,n) #Saves space for the amount of steps we take.\n  va <- runif(n) #We need a random number for each step.\n  for(i in 1:n){ #We need to take n steps.\n    point <- FALSE #Used to check if we found a point\n    j <- 1 #We start from 1, when checking probabilities.\n    while(point == FALSE){ #We have to check up to \"width\" to get a point.\n      if(va[i] <= p[k,j]){ #If the random number corresponds to the probability of that state\n        point = TRUE #We found a point\n        road[i] = j #Save it on the \"road\"\n        k = j #Set our new starting state as the state j we found.\n      } else{ #If the random number is not correct\n        va[i] <- va[i] - p[k,j] #We subtract the probability so that it corresponds to the rest.\n        j <- j + 1 #We check the next probability state.\n      }\n    }\n  }\n  stationary <- rep(0,width) #We need \"width\" numbers to be returned\n  for(i in 1:width){ #We sum the amount of times we were at each state, and divide by number of steps.\n    stationary[i] = sum(road == i)/n\n  }\n  return(stationary) #We return a vector that corresponds to stationary probability of each state in numerical order.\n}\n",
    "created" : 1465306192290.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3693289266",
    "id" : "DDAB335A",
    "lastKnownWriteTime" : 1465311444,
    "path" : "C:/Users/Emil/Dropbox/Universitet/ST522/FinalProjectCombined/GitHub/LemilExamST522/R/mc.discrete.R",
    "project_path" : "R/mc.discrete.R",
    "properties" : {
        "tempName" : "Untitled2"
    },
    "relative_order" : 8,
    "source_on_save" : false,
    "type" : "r_source"
}