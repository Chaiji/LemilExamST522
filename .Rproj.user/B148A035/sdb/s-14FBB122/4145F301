{
    "contents" : "\n#' @title Density Estimator\n#' @export\n#' @return Depending on input, either returns density on specific points d, or returns a bandwidth as well as a table of densities estimated\n#' at points on data given as: minimum, 1st quantile, median, mean, 3rd quantile, and maximum of x.\n#' @usage dens.estimator(x,d,h,method=\"naive\")\n#' @keywords estimate density silverman struges sturges bandwidth data kernel gaussian naive\n#' @description This function takes between 1 and 4 arguments to estimate density of data.\n#' @param x is data given as a vector of numbers, to estimate density from.\n#' @param d is a number or a vector of numbers, that specifies what points density should be returned for. If nothing is chosen, a table of\n#' relevant values are given: Min, 1st quantile, median, mean, 3rd quantile and max of the input data x.\n#' @param h is a positive number that specifies the bandwidth used for the density estimation. If nothing is chosen, h is estimated\n#' using either Struges method or Silverman's method, depending on the method parameter.\n#' @param method is an argument that is either \"naive\" or \"kernel\", deciding the method of estimating the density. Defaults to \"naive\".\n#' @author Nguyen Khanh Le Ho & Emil H. Andersen \\cr\n#' Department of Mathematics and Computer Science (IMADA) \\cr\n#' University of Southern Denmark, Denmark \\cr\n#' \\email{emila14@student.sdu.dk} \\cr\n#' \\email{ngho14@student.sdu.dk} \\cr\n#' @examples\n#' dens.estimator(cars$speed)\n#' dens.estimator(cars$speed,method=\"kernel\")\n#' dens.estimator(cars$speed,10,3,method=\"naive\")\n\ndens.estimator <- function(x,d,h,method=\"naive\"){\n  #------------------------------------Error Handler:--------------------------------------------#\n  # ---------------------------------------------------------------------------------------------#\n  # x is a vector of numbers                                                                     #\n  # d is a numeric value, can be a vector                                                        #\n  # h is a positive numeric value, if no input, use Struges or Silvermans depending on method    #\n  # method is a string that either contains \"naive\" or \"kernel\", defaults to \"naive\"             #\n  #----------------------------------------------------------------------------------------------#\n  if(is.list(x) || !is.numeric(x) || is.matrix(x) || !is.vector(x)   ){\n    stop(\" The given data 'x' must be a numerical vector.\")\n  }\n  if(!missing(d)){\n    if(is.list(d) || !is.numeric(d) || is.matrix(d) || !is.vector(d)   ){\n      stop(\" The given point(s) 'd' must be a number or a vector of numbers.\")\n    }\n  }\n  if(!missing(h)){\n    if(is.list(h) || !is.numeric(h) || is.matrix(h) || length(h) != 1 || h < 0){\n      stop(\" The given bandwidth 'h' must be a single positive number.\")\n    }\n  }\n  if(method != \"naive\" && method != \"kernel\"){\n    stop(\"The given argument 'method' has to be either 'naive' or 'kernel'\")\n  }\n  #---------------------------------------End Error Handler--------------------------------------#\n  if(missing(d)){\n    d <- c(min(x),quantile(x,0.25,names=FALSE),median(x),mean(x),quantile(x,0.75,names=FALSE),max(x))\n    tableplease <- TRUE #If user did not choose d, we use a table. This boolean value decides that.\n  } else{\n    tableplease <- FALSE #If user chooses d, output is exactly the result of evaluating d.\n  }\n  n <- length(x) #n is the amount of values in x. This information is needed regardless of estimator\n  f <- rep(0,length(d))\n  if(method == \"naive\"){ #Naive estimator\n    if(missing(h)){ #If h not given, but method is naive.\n      h <- diff(range(x)/(1+log2(n))) #h is chosen based on Sturges method of choosing bandwidth.\n    }\n    w <- matrix(rep(0,length(x)*length(d)),nrow=length(d),ncol=length(x)) #Allows calculating multiple values for d simultaneously using a matrix\n    for (j in 1:length(d)){ #We need to check a row of values for every value in d.\n      for(i in 1:length(x)){ #We need to check every x.\n        if(abs((d[j] - x[i])/h) < 1){ #Easier to calculate each w beforehand and then sum them later\n          w[j,i] <- 1/2\n        }\n      }\n    }\n    for(i in 1:length(d)){\n      f[i] <- (1/(n*h)) * sum(w[i,]) #f are calculated\n    }\n  } else if(method ==\"kernel\"){\n    if(missing(h)){ #If h not given, but method is kernel\n      h <- ((4*sd(x)^5)/(3*n))^(1/5) #h is chosen based on Silvermans suggestion for choosing bandwidth for Gaussian functions.\n    }\n    K <- matrix(rep(0,length(x)*length(d)),nrow=length(d),ncol=length(x))\n    for(j in 1:length(d)){\n      for(i in 1:length(x)){ #Easier to calculate each K beforehand and then sum them later\n        u <- (d[j] - x[i])/h\n        K[j,i] <- (1/(sqrt(2*pi)))*exp(-(1/2)*u^2)\n      }\n    }\n    for(i in 1:length(d)){ #f are calculated\n      f[i] <- (1/(n*h))*sum(K[i,])\n    }\n  }\n  if(tableplease == TRUE){ #If user did not choose d, return a table of information.\n    fr <- data.frame(x=d, y=f, row.names=c(\"Min.\",\"1st Qu.\",\"Median\",\"Mean\",\"3rd Qu.\",\"Max.\"))\n    return(list(\"BandWidth\" = h, \"Data\" = fr))\n  } else{\n    return(f)\n  }\n}\n",
    "created" : 1465124151518.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1424074089",
    "id" : "4145F301",
    "lastKnownWriteTime" : 1465299489,
    "path" : "C:/Users/Emil/Dropbox/Universitet/ST522/FinalProjectCombined/GitHub/LemilExamST522/R/dens.estimator.R",
    "project_path" : "R/dens.estimator.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "type" : "r_source"
}