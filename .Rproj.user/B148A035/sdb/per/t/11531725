{
    "contents" : "\n#' @title Density Plotter\n#' @export\n#' @return Returns a density plot over the input data x, with information calculated depending on other inputs, or lack thereof.\n#' @usage dens.plot(x,n=500,method=\"naive\",from,to)\n#' @keywords estimate density silverman struges sturges bandwidth data plot naive kernel gaussian\n#' @description This function takes between 1 and 5 arguments to plot the density of data, using the dens.estimator function.\n#' @param x is data given as a vector of numbers, to estimate density from.\n#' @param n is a positive integer that specifies the number of points to be used for plotting the density function. Defaults to 500.\n#' @param method is an argument that is either \"naive\" or \"kernel\", deciding the method of estimating the density. Defaults to \"naive\".\n#' @param from is a number that specifies where the plot should start. Defaults to min(x)-sd(x)/3\n#' @param to is a number that specifies where the plot should end. Defaults to max(x)+sd(x)/3\n#' @author Nguyen Khanh Le Ho & Emil H. Andersen \\cr\n#' Department of Mathematics and Computer Science (IMADA) \\cr\n#' University of Southern Denmark, Denmark \\cr\n#' \\email{emila14@student.sdu.dk} \\cr\n#' \\email{ngho14@student.sdu.dk} \\cr\n#' @examples\n#' dens.plot(cars$speed)\n#' dens.plot(cars$speed,method=\"kernel\")\n#' dens.plot(cars$speed,n=512,method=\"naive\", from=10, to=20)\n\ndens.plot <- function(x,n=500,method=\"naive\",from,to){\n  #------------------------------------Error Handler:--------------------------------------------#\n  # ---------------------------------------------------------------------------------------------#\n  # x is a vector of numbers                                                                     #\n  # n is the number of points to be used for plotting the density function. default is 500       #\n  # method is a string that either contains \"naive\" or \"kernel\", defaults to \"naive\"             #\n  # from is a number for where to start plot. If none chosen, calculates based on sd(x)          #\n  # to is a number for where to end plot. If none chosen, calculates based on sd(x)              #\n  #----------------------------------------------------------------------------------------------#\n  if(is.list(x) || !is.numeric(x) || is.matrix(x) || !is.vector(x)   ){\n    stop(\" The given data 'x' must be a numerical vector.\")\n  }\n  if(is.matrix(n) || is.list(n) || length(n)!=1){ #Check that n is a single value\n    stop(\"'n' has to be a positive integer; length=1, non-list, non-matrix\")\n  } else if(!is.numeric(n)){ #checks if n is a number\n    stop(\"'n' has to be a positive integer\")\n  } else if(n < 1 || n != round(n)){ #checks if n is a natural number\n    stop(\"'n' has to be a positive integer\")\n  }\n  if(method != \"naive\" && method != \"kernel\"){\n    stop(\"The given argument 'method' has to be either 'naive' or 'kernel'\")\n  }\n  if(!missing(from)){\n    if(is.matrix(from) || is.list(from) || length(from)!=1){ #Check that n is a single value\n      stop(\"'from' has to be a number; length=1, non-list, non-matrix\")\n    } else if(!is.numeric(n)){ #checks if n is a number\n      stop(\"'from' has to be a number\")\n    }\n  }\n  if(!missing(to)){\n    if(is.matrix(to) || is.list(to) || length(to)!=1){ #Check that n is a single value\n      stop(\"'to' has to be a number; length=1, non-list, non-matrix\")\n    } else if(!is.numeric(to)){ #checks if n is a number\n      stop(\"'to' has to be a number\")\n    }\n  }\n  #---------------------------------------End Error Handler--------------------------------------#\n  if(missing(from)){ #From is chosen as minimum of x, minus standard deviation/3\n    from <- min(x) - sd(x)/3\n  }\n  if(missing(to)){ #To is chosen as maxmimum of x, plus standard deviation/3\n    to <- max(x) + sd(x)/3\n  }\n  if(from > to){ #If somehow from is greater than to, flip them. Defensive measure!\n    temp <- to\n    to <- from\n    from <- temp\n  }\n  intervalX <- seq(from,to,(diff(c(from,to))/n))\n  if(method==\"naive\"){\n    intervalY <- dens.estimator(x,d=intervalX,method=\"naive\")\n    plot(intervalX,intervalY, main=\"Naive estimator\", xlab=\"points\", ylab=\"density\", type=\"l\")\n  } else if(method==\"kernel\"){\n    intervalY <- dens.estimator(x,d=intervalX,method=\"kernel\")\n    plot(intervalX,intervalY, main=\"Gaussian estimator\", xlab=\"points\", ylab=\"density\", type=\"l\")\n  }\n}\n",
    "created" : 1465124348397.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2982869974",
    "id" : "11531725",
    "lastKnownWriteTime" : 1465129848,
    "path" : "C:/Users/Emil/Dropbox/Universitet/ST522/FinalProjectCombined/GitHub/LemilExamST522/R/dens.plot.R",
    "project_path" : "R/dens.plot.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "type" : "r_source"
}