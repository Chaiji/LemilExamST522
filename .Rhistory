storage <- matrix(rep(0,lx*n), nrow = lx)
Pr <- rep(0,length(x))
for(k in 1:lx){
for(i in 1:n){
storage[k,i]<- sum(rnorm(df)^2)
}
}
for(j in 1: lx){
Pr[j] <- length(storage[j,][storage[j,] > x[j]])/n
}
if(plot==TRUE){
par(mfrow=c(2,1))
plot(density(storage[1,]))
plot(ecdf(storage[1,]))
}
return(Pr)
}
chi.probability(c(5,4), 5, 1000)
storage <- matrix(rep(0,2*10),nrow=lx)
storage <- matrix(rep(0,2*10),nrow=1)
storage
storage <- matrix(rep(0,2*10),nrow=2)
storage
storage[1,] <- sum(rnorm(5)^2)
storage
storage <- sum(rnorm(5)^2)
storage
storage <- matrix(rep(0,2*10),nrow=2)
storage[,] <- sum(rnorm(5)^2)
storage
chi.probability <- function(x, df = 5, n = 1000,  plot = FALSE){
#------------------------------------Error Handler:--------------------------------------#
# ---------------------------------------------------------------------------------------#
# 'n' and 'df' must be numeric, natural number greater than 1.                           #
# 'x' must be a numerical vector.                                                        #
# 'plot' must be a boolean value.                                                        #
#----------------------------------------------------------------------------------------#
if(!is.numeric(n) || n!= round(n) || n < 1 || length(n)>1){ #Check that n is a single natural number
stop("'n' must be a natural number")
}
if(!is.logical(plot) || length(plot)>1){ #Check that plot is a single boolean value
stop("'plot' must be logical non-vector.")
}
if(!is.numeric(df) || df!= round(df) || df < 1 || length(df)>1 ){ #Check that df is a single natural number
stop(" df must be a natural number")
}
if(is.matrix(x) || is.list(x) || !is.numeric(x)){ #Check that x is a vector of numbers(can be any length)
stop("'x' has to be an integer; non-list, non-matrix")
}
#---------------------------------------End Error Handler---------------------------------#
lx <- length(x) #Save the length of x for later
storage <- matrix(rep(0,lx*n), nrow = lx) #Generate a matrix so rows are used for multiple different chi probabilities(if x is longer than 1. Defensive)
Pr <- rep(0,length(x)) #Create Pr to save results in.
for(k in 1:lx){ #For every different x, we create values for Pr.
for(i in 1:n){ #We want n numbers for each different x.
storage[k,i]<- sum(rnorm(df)^2) #Chi values
}
}
for(j in 1: lx){ #For every different x, we create a different P-value
Pr[j] <- length(storage[j,][storage[j,] > x[j]])/n #We get P(chi^2 > x)
}
if(plot==TRUE){ #If user wants, we can plot the density function and the empirical cumulative distribution function
par(mfrow=c(2,1)) #Makes space for 2 graphs
plot(density(storage[1,]), main = "Density function") #Plots density function
plot(ecdf(storage[1,]))
}
return(Pr)
}
chi.probability(c(5,4), 5, 1000, TRUE)
chi.probability <- function(x, df = 5, n = 1000,  plot = FALSE){
#------------------------------------Error Handler:--------------------------------------#
# ---------------------------------------------------------------------------------------#
# 'n' and 'df' must be numeric, natural number greater than 1.                           #
# 'x' must be a numerical vector.                                                        #
# 'plot' must be a boolean value.                                                        #
#----------------------------------------------------------------------------------------#
if(!is.numeric(n) || n!= round(n) || n < 1 || length(n)>1){ #Check that n is a single natural number
stop("'n' must be a natural number")
}
if(!is.logical(plot) || length(plot)>1){ #Check that plot is a single boolean value
stop("'plot' must be logical non-vector.")
}
if(!is.numeric(df) || df!= round(df) || df < 1 || length(df)>1 ){ #Check that df is a single natural number
stop(" df must be a natural number")
}
if(is.matrix(x) || is.list(x) || !is.numeric(x)){ #Check that x is a vector of numbers(can be any length)
stop("'x' has to be an integer; non-list, non-matrix")
}
#---------------------------------------End Error Handler---------------------------------#
lx <- length(x) #Save the length of x for later
storage <- matrix(rep(0,lx*n), nrow = lx) #Generate a matrix so rows are used for multiple different chi probabilities(if x is longer than 1. Defensive)
Pr <- rep(0,length(x)) #Create Pr to save results in.
for(k in 1:lx){ #For every different x, we create values for Pr.
for(i in 1:n){ #We want n numbers for each different x.
storage[k,i]<- sum(rnorm(df)^2) #Chi values
}
}
for(j in 1: lx){ #For every different x, we create a different P-value
Pr[j] <- length(storage[j,][storage[j,] > x[j]])/n #We get P(chi^2 > x)
}
if(plot==TRUE){ #If user wants, we can plot the density function and the empirical cumulative distribution function
par(mfrow=c(2,lx)) #Makes space for 2 graphs for each x.
for(i in 1:lx){
plot(density(storage[i,]), main = "Density function") #Plots density function
}
for(i in 1:lx){
plot(ecdf(storage[i,]))
}
}
return(Pr)
}
chi.probability(c(5,4), 5, 1000, TRUE)
chi.probability(c(5,4), 5, 1000, TRUE)
chi.probability(c(5,4,3), 5, 1000, TRUE)
plot(1,2)
chi.probability <- function(x, df = 5, n = 1000,  plot = FALSE){
#------------------------------------Error Handler:--------------------------------------#
# ---------------------------------------------------------------------------------------#
# 'n' and 'df' must be numeric, natural number greater than 1.                           #
# 'x' must be a numerical vector.                                                        #
# 'plot' must be a boolean value.                                                        #
#----------------------------------------------------------------------------------------#
if(!is.numeric(n) || n!= round(n) || n < 1 || length(n)>1){ #Check that n is a single natural number
stop("'n' must be a natural number")
}
if(!is.logical(plot) || length(plot)>1){ #Check that plot is a single boolean value
stop("'plot' must be logical non-vector.")
}
if(!is.numeric(df) || df!= round(df) || df < 1 || length(df)>1 ){ #Check that df is a single natural number
stop(" df must be a natural number")
}
if(is.matrix(x) || is.list(x) || !is.numeric(x)){ #Check that x is a vector of numbers(can be any length)
stop("'x' has to be an integer; non-list, non-matrix")
}
#---------------------------------------End Error Handler---------------------------------#
lx <- length(x) #Save the length of x for later
storage <- matrix(rep(0,lx*n), nrow = lx) #Generate a matrix so rows are used for multiple different chi probabilities(if x is longer than 1. Defensive)
Pr <- rep(0,length(x)) #Create Pr to save results in.
for(k in 1:lx){ #For every different x, we create values for Pr.
for(i in 1:n){ #We want n numbers for each different x.
storage[k,i]<- sum(rnorm(df)^2) #Chi values
}
}
for(j in 1: lx){ #For every different x, we create a different P-value
Pr[j] <- length(storage[j,][storage[j,] > x[j]])/n #We get P(chi^2 > x)
}
if(plot==TRUE){ #If user wants, we can plot the density function and the empirical cumulative distribution function
par(mfrow=c(2,lx)) #Makes space for 2 graphs for each x.
for(i in 1:lx){
plot(density(storage[i,]), main = "Density function") #Plots density function
}
for(i in 1:lx){
plot(ecdf(storage[i,]))
}
par(mfrow=c(1,1))
}
return(Pr)
}
chi.probability(c(5,4,3), 5, 1000, TRUE)
plot(1,2)
chi.probability <- function(x, df = 5, n = 1000,  plot = FALSE){
#------------------------------------Error Handler:--------------------------------------#
# ---------------------------------------------------------------------------------------#
# 'n' and 'df' must be numeric, natural number greater than 1.                           #
# 'x' must be a numerical vector.                                                        #
# 'plot' must be a boolean value.                                                        #
#----------------------------------------------------------------------------------------#
if(!is.numeric(n) || n!= round(n) || n < 1 || length(n)>1){ #Check that n is a single natural number
stop("'n' must be a natural number")
}
if(!is.logical(plot) || length(plot)>1){ #Check that plot is a single boolean value
stop("'plot' must be logical non-vector.")
}
if(!is.numeric(df) || df!= round(df) || df < 1 || length(df)>1 ){ #Check that df is a single natural number
stop(" df must be a natural number")
}
if(is.matrix(x) || is.list(x) || !is.numeric(x)){ #Check that x is a vector of numbers(can be any length)
stop("'x' has to be an integer; non-list, non-matrix")
}
#---------------------------------------End Error Handler---------------------------------#
lx <- length(x) #Save the length of x for later
storage <- matrix(rep(0,lx*n), nrow = lx) #Generate a matrix so rows are used for multiple different chi probabilities(if x is longer than 1. Defensive)
Pr <- rep(0,length(x)) #Create Pr to save results in.
for(k in 1:lx){ #For every different x, we create values for Pr.
for(i in 1:n){ #We want n numbers for each different x.
storage[k,i]<- sum(rnorm(df)^2) #Chi values
}
}
for(j in 1: lx){ #For every different x, we create a different P-value
Pr[j] <- length(storage[j,][storage[j,] > x[j]])/n #We get P(chi^2 > x)
}
if(plot==TRUE){ #If user wants, we can plot the density function and the empirical cumulative distribution function
par(mfrow=c(2,lx)) #Makes space for 2 graphs for each x.
for(i in 1:lx){
plot(density(storage[i,]), xlab = "x", main = "Density function") #Plots density functions
}
for(i in 1:lx){
plot(ecdf(storage[i,]))
}
par(mfrow=c(1,1))
}
return(Pr)
}
chi.probability(c(5,4,3), 5, 1000, TRUE)
chi.probability <- function(x, df = 5, n = 1000,  plot = FALSE){
#------------------------------------Error Handler:--------------------------------------#
# ---------------------------------------------------------------------------------------#
# 'n' and 'df' must be numeric, natural number greater than 1.                           #
# 'x' must be a numerical vector.                                                        #
# 'plot' must be a boolean value.                                                        #
#----------------------------------------------------------------------------------------#
if(!is.numeric(n) || n!= round(n) || n < 1 || length(n)>1){ #Check that n is a single natural number
stop("'n' must be a natural number")
}
if(!is.logical(plot) || length(plot)>1){ #Check that plot is a single boolean value
stop("'plot' must be logical non-vector.")
}
if(!is.numeric(df) || df!= round(df) || df < 1 || length(df)>1 ){ #Check that df is a single natural number
stop(" df must be a natural number")
}
if(is.matrix(x) || is.list(x) || !is.numeric(x)){ #Check that x is a vector of numbers(can be any length)
stop("'x' has to be an integer; non-list, non-matrix")
}
#---------------------------------------End Error Handler---------------------------------#
lx <- length(x) #Save the length of x for later
storage <- matrix(rep(0,lx*n), nrow = lx) #Generate a matrix so rows are used for multiple different chi probabilities(if x is longer than 1. Defensive)
Pr <- rep(0,length(x)) #Create Pr to save results in.
for(k in 1:lx){ #For every different x, we create values for Pr.
for(i in 1:n){ #We want n numbers for each different x.
storage[k,i]<- sum(rnorm(df)^2) #Chi values
}
}
for(j in 1: lx){ #For every different x, we create a different P-value
Pr[j] <- length(storage[j,][storage[j,] > x[j]])/n #We get P(chi^2 > x)
}
if(plot==TRUE){ #If user wants, we can plot the density function and the empirical cumulative distribution function
par(mfrow=c(2,lx)) #Makes space for 2 graphs for each x.
for(i in 1:lx){
plot(density(storage[i,]), xlab = "x", main = "Density function") #Plots density functions
}
for(i in 1:lx){
plot(ecdf(storage[i,]), main = "ECDF")
}
par(mfrow=c(1,1))
}
return(Pr)
}
chi.probability(c(5,4,3), 5, 1000, TRUE)
list(TRUE)
length(list(TRUE))
is.logical(list(TRUE))
is.logical(matrix(TRUE))
matrix(TRUE) == TRUE
if(matrix(TRUE) == TRUE){print("yes")}
chi.gof <- function(x,p){
#Syntax Processing
#============================================================
#First we check if x is a vector of numbers
if(!is.vector(x) || is.matrix(x) || is.list(x) || !is.numeric(x)){
stop("'x' has to be a vector of numbers.(Non list, non matrix)")
}
if(missing(p)){ #If p is not used, probability is uniform
p <- rep((1/length(x)),length(x))
} else if(!is.vector(p) || is.matrix(p) || is.list(p) || !is.numeric(p)){
stop("'p' has to be a vector of numbers.(Non list, non matrix)") #If p exist, check it is a vector of numbers
} else if(length(p) != length(x)){
stop("'p' and 'x' has to be of the same length")
}
if(sum(p) != 1){ #Warn the user if the total probability does not equal to 1.
warning("Sum of p is not equal to 1, this may cause incorrect calculations.")
}
checker <- p<0
checker2 <- x<0
if(length(checker[checker == TRUE]) > 0){ #Warn the user if they added negative probabilities
warning("p contains negative values, this may cause incorrect calculations.")
}
if(length(checker2[checker2 == TRUE]) > 0){ #Warn the user if they added negative values to x
warning("x contains negative values, this may cause incorrect calculations.")
}
#------------------------------------------------------------
k <- length(x) #Calculating chi.probability requires the degrees of freedom
n <- sum(x) #We need to know how many there are in total for Pearson's Chi-squared statistic
return(sum(((x - n*p)^2)/(n*p))) #Formula to calculate Pearson's Chi-squared statistic
}
chi.test <- function(x,p){
#------------------------------------Error Handler:--------------------------------------#
# ---------------------------------------------------------------------------------------#
# 'x' must be a vector of positive numbers                                               #
# 'p' must be a vector of probabilities. If not chosen, program decides uniform          #
#----------------------------------------------------------------------------------------#
#First we check if x is a vector of numbers
if(!is.vector(x) || is.matrix(x) || is.list(x) || !is.numeric(x)){
stop("'x' has to be a vector of numbers.(Non list, non matrix)")
}
if(missing(p)){ #If p is not used, probability is uniform
p <- rep((1/length(x)),length(x))
} else if(!is.vector(p) || is.matrix(p) || is.list(p) || !is.numeric(p)){
stop("'p' has to be a vector of numbers.(Non list, non matrix)") #If p exist, check it is a vector of numbers
} else if(length(p) != length(x)){
stop("'p' and 'x' has to be of the same length")
}
if(sum(p) != 1){ #Warn the user if the total probability does not equal to 1.
warning("Sum of p is not equal to 1, this may cause incorrect calculations.")
}
if(length(length(p[p<0])>0)){ #Warn the user if they added negative probabilities
stop("p contains negative values, this will cause incorrect calculations.")
}
if(length(length(x[x<0])>0)){ #Warn the user if they added negative values to x
stop("x contains negative values, this will cause incorrect calculations.")
}
#---------------------------------------End Error Handler---------------------------------#
n <- sum(x) #We need to know how many there are in total for Pearson's Chi-squared statistic
return(sum(((x - n*p)^2)/(n*p))) #Formula to calculate Pearson's Chi-squared statistic
}
chi.test(c(1,2,3),c(0.25,0.6,0.15))
chi.test <- function(x,p){
#------------------------------------Error Handler:--------------------------------------#
# ---------------------------------------------------------------------------------------#
# 'x' must be a vector of positive numbers                                               #
# 'p' must be a vector of probabilities. If not chosen, program decides uniform          #
#----------------------------------------------------------------------------------------#
#First we check if x is a vector of numbers
if(!is.vector(x) || is.matrix(x) || is.list(x) || !is.numeric(x)){
stop("'x' has to be a vector of numbers.(Non list, non matrix)")
}
if(missing(p)){ #If p is not used, probability is uniform
p <- rep((1/length(x)),length(x))
} else if(!is.vector(p) || is.matrix(p) || is.list(p) || !is.numeric(p)){
stop("'p' has to be a vector of numbers.(Non list, non matrix)") #If p exist, check it is a vector of numbers
} else if(length(p) != length(x)){
stop("'p' and 'x' has to be of the same length")
}
if(sum(p) != 1){ #Warn the user if the total probability does not equal to 1.
warning("Sum of p is not equal to 1, this may cause incorrect calculations.")
}
if(length(length(p[p<0]))>0){ #Warn the user if they added negative probabilities
stop("p contains negative values, this will cause incorrect calculations.")
}
if(length(length(x[x<0]))>0){ #Warn the user if they added negative values to x
stop("x contains negative values, this will cause incorrect calculations.")
}
#---------------------------------------End Error Handler---------------------------------#
n <- sum(x) #We need to know how many there are in total for Pearson's Chi-squared statistic
return(sum(((x - n*p)^2)/(n*p))) #Formula to calculate Pearson's Chi-squared statistic
}
chi.test(c(1,2,3),c(0.25,0.6,0.15))
x <- c(1,2,3)
p <- c(0.25,0.6,0.15)
p[p<0]
length(p[p<0])
length(length(p[p<0]))>0
length(length(p[p<0]))
length(p[p<0])>0
chi.test <- function(x,p){
#------------------------------------Error Handler:--------------------------------------#
# ---------------------------------------------------------------------------------------#
# 'x' must be a vector of positive numbers                                               #
# 'p' must be a vector of probabilities. If not chosen, program decides uniform          #
#----------------------------------------------------------------------------------------#
#First we check if x is a vector of numbers
if(!is.vector(x) || is.matrix(x) || is.list(x) || !is.numeric(x)){
stop("'x' has to be a vector of numbers.(Non list, non matrix)")
}
if(missing(p)){ #If p is not used, probability is uniform
p <- rep((1/length(x)),length(x))
} else if(!is.vector(p) || is.matrix(p) || is.list(p) || !is.numeric(p)){
stop("'p' has to be a vector of numbers.(Non list, non matrix)") #If p exist, check it is a vector of numbers
} else if(length(p) != length(x)){
stop("'p' and 'x' has to be of the same length")
}
if(sum(p) != 1){ #Warn the user if the total probability does not equal to 1.
warning("Sum of p is not equal to 1, this may cause incorrect calculations.")
}
if(length(p[p<0])>0){ #Warn the user if they added negative probabilities
stop("p contains negative values, this will cause incorrect calculations.")
}
if(length(x[x<0])>0){ #Warn the user if they added negative values to x
stop("x contains negative values, this will cause incorrect calculations.")
}
#---------------------------------------End Error Handler---------------------------------#
n <- sum(x) #We need to know how many there are in total for Pearson's Chi-squared statistic
return(sum(((x - n*p)^2)/(n*p))) #Formula to calculate Pearson's Chi-squared statistic
}
chi.test(c(1,2,3),c(0.25,0.6,0.15))
chi.test(c(1,2,3),c(0.25,0.6,0.15))
chi.test(c(1,2,3),c(0.25,0.6,0.15))
chi.test(c(1,2,3),c(0.25,0.6,0.15))
chi.probability <- function(x, df = 5, n = 1000,  plot = FALSE){
#------------------------------------Error Handler:--------------------------------------#
# ---------------------------------------------------------------------------------------#
# 'n' and 'df' must be numeric, natural number greater than 1.                           #
# 'x' must be a numerical vector.                                                        #
#----------------------------------------------------------------------------------------#
if(is.matrix(n) || is.list(n) || length(n)!=1){ #Check that n is a single value
stop("'n' has to be a positive integer; length=1, non-list, non-matrix")
} else if(!is.numeric(n)){ #checks if n is a number
stop("'n' has to be a positive integer")
} else if(n < 1 || n != round(n)){ #checks if n is a natural number
stop("'n' has to be a positive integer")
}
if(is.matrix(df) || is.list(df) || length(df)!=1){ #Check that df is a single value
stop("'df' has to be an integer; length=1, non-list, non-matrix")
} else if(!is.numeric(df)){ #checks if df is a number
stop("'df' has to be a positive integer")
} else if(df < 1){ #checks if df is a positive integer
stop("'df' has to be a positive integer")
}
if(is.matrix(x) || is.list(x) || !is.numeric(x)){ #Check that x is a vector of numbers(can be any length)
stop("'x' has to be an integer; non-list, non-matrix")
}
#---------------------------------------End Error Handler---------------------------------#
lx <- length(x) #Save the length of x for later
storage <- matrix(rep(0,lx*n), nrow = lx) #Generate a matrix so rows are used for multiple different chi probabilities(if x is longer than 1. Defensive)
Pr <- rep(0,length(x)) #Create Pr to save results in.
for(k in 1:lx){ #For every different x, we create values for Pr.
for(i in 1:n){ #We want n numbers for each different x.
storage[k,i]<- sum(rnorm(df)^2) #Chi values
}
}
for(j in 1: lx){ #For every different x, we create a different P-value
Pr[j] <- length(storage[j,][storage[j,] > x[j]])/n #We get P(chi^2 > x)
}
return(Pr) #Returns the p-value
}
chi.test(c(1,2,3),c(0.25,0.6,0.15))
chi.probability(5.777778,5,1000)
library(LemilExamST522)
roxygen2::roxygenise()
linear.model <- function(formula){
#------------------------------------Error Handler:--------------------------------------#
# ---------------------------------------------------------------------------------------#
# 'formula' has to be of the type 'language'                                             #
#----------------------------------------------------------------------------------------#
#We only check that 'formula' is of the correct type, because this type of input is very
#hard to work with, we don't know what else to check for.
if(typeof(formula) != "language"){
stop("Your input must be presented in the language type, see documentation for examples")
}
#---------------------------------------End Error Handler---------------------------------#
call <- match.call() #This one is saved for the summary at the end of the function
mf <- match.call() #This is used for setting up our matrix. This is equal to the exact call
mf[[1L]] <- quote(stats::model.frame) #Change the called function in the call to stats::model.frame. Evaluating this gives us what we need
mf <- eval(mf, parent.frame()) #This evaluates our model frame using information from the parent environment.
#Most calculations below are done based on chapter 5 of "A modern approach to regression with R"
#Page referrences are to that book.
width <- dim(mf)[2] #Save the information about the dimensions of the matrix. This is needed for later. In the regression book, width=p-1
height <- dim(mf)[1] #Also saved for later. height = n
Y <- mf[,1] #Y is the dependent variable. Page 131 in book.
X <- rep(1,height) #X is a matrix that contains a column of 1s, and then columns of the other data. Page 131 in book.
for(i in 2:width){
X <- cbind(X,mf[,i]) #The other variables are added. Page 131 in book.
}
bEst <- as.vector(solve((t(X)%*%X))%*%t(X)%*%Y) #bEst is the estimated betas. Page 132 formula (5.6). Solve inverts a matrix, t() transposes a matrix, %*% is matrix multiplication.
Yhat <- X%*%bEst #Estimated Y's, so caleld Yhat. Page 132 formula (5.7)
residuals <- as.vector(Y - Yhat) #Estimated error, i.e. residuals, so called ehat. Page 132 formula (5.8)
RSE <- sd(residuals) #Residual standard error is equal to the standard deviation of the residuals
RSS <- sum((residuals)^2) #Least squares estimates, needed for Rsquare. Page 135 top.
SST <- sum((Y - mean(Y))^2) #Sum of squares of Y, needed for Rsquare. Page 135 bottom.
Rsquare <- 1 - (RSS/SST) #Multiple R-squared calculated using RSS and SST. Page 136 Note 1.
RsquareAdj <- 1 - (RSS/(height-width-2))/(SST/(height-1)) #Adjusted R-squared, using formula from book. Reminder: height = n, width = p - 1. Page 137 Note 1.
SSreg <- sum((Yhat - mean(Y))^2) #Page 135 bottom. Used to calculate the F-statistic
Fstat <- (SSreg/(width-1))/(RSS/(height-width-2)) #Formula to calculate F-statistic. Page 136 middle.
df <- height - width #degrees of freedom is generally the amount of data minus the amount of different parameters.
pval <- 1 - pf(Fstat,width-1,height-width-2) #To calculate the p-value, I use F-statistics, since we already have the Fstat.
SS <- (1/(height - width - 2))*sum((residuals)^2) #Error variance, S^2. Page 135 top.
SE <- as.vector(sqrt(diag(SS*solve(t(X)%*%X)))) #Standard Error. Page 134 Var(betahat|X), replace sigma^2 by SS. Note that Diag is used because all outliers are irrelevant. Book does not explain why
Tval <- bEst/SE #Page 135, middle. t-value, note that beta_i is 0, and so isnt in the equation
Pr <- 1-pt(abs(Tval),df) #Pr(>|t|) values. Calculated directly as it is described, using t distribution.
#Making the table for residuals, based on how summary() would do it.
res <- data.frame("Min" = min(residuals),"Q1"=quantile(residuals,0.25,names=FALSE), "Median" = median(residuals), "Q3"=quantile(residuals,0.75,names=FALSE), "Max" = max(residuals), row.names='')
#Getting the names of the things for coefficient table
y <- toString(call[2]) #Gets the entire argument as a string
y2 <- strsplit(y, c("+"), fixed = TRUE) #Splits into parts based on +
y3 <- unique(y2[[1]]) #Makes it into a vector of strings, that contains unique instances in it.
y4 <- strsplit(y3[1], c(" "), fixed = TRUE) #splits the first part of the argument, namely "dependent ~ variable"
if(length(y3) > 2){ #Depending on how many more variables is chosen after the first, we piece them together accordingly in a vector.
y3 <- y3[2:length(y3)] #If there is more than 1.
} else if(length(y3) == 2){
y3 <- y3[2] #If there is exactly 1 more.
} else{
y3 <- c() #If there is only 1 variable after ~, then y3 is no longer needed.
}
y4 <- unique(y4[[1]]) #We turn this into a vector of strings
y4 <- y4[3] #We are not interested in the dependent variable or the ~, so we remove them
y5 <- c(y4,y3) #We combine y4 and y3.
y5 <- trimws(y5) #We trim away whitespace in the strings.
#Coefficient table names
coefNames <- c("(Intercept)") #The first coefficient name is always (intercept)
for(i in 1:length(bEst)-1){ #we know that we need names for length(bEst)-1 variables.
coefNames <- c(coefNames,y5[i]) #Name vector is created properly
}
if(length(y5) > length(bEst)-1){ #If we did not use all the names, it means there is something wrong with the input. User is notified.
message("Some inputs were ignored, please try the I() function, and see if this helps. Examples can be found in the help file.")
}
coef <- data.frame("Estimate" = bEst, "Std.Error" = SE, "t value" = Tval, "Pr.t" = Pr, row.names=coefNames) #The coefficients are saved as a data.frame. We chose this over a table as we found this easier to work with.
print(list("Call" = call, "Residuals" = res, "Coefficients" = coef)) #Prints a list containing the call, the residuals and the coefficients just like summary()
print(paste0("Residual standard error: ",format(RSE,digits=4)," on ",df," degrees of freedom")) #Prints extra information, namely RSE with 4 digits, as well as degrees of freedom.
print(paste0("Multiple R-squared: ",format(Rsquare,digits=4), ", Adjusted R-squared: ", format(RsquareAdj,digits=4))) #Extra information, R^2 and R_Adj^2
print(paste0("F-statistic: ", format(Fstat,digits=4), ", p-value: ", format(pval,3))) #Extra information, F-statistic and p-value
#Returns residuals, RSE, R^2, R_Adj^2, F-statistic, degrees of freedom, p-value as well as the coefficient data.frame. This is done using invisible so it does NOT print it unless user explicitly asks for it later.
return(invisible(list("residuals" = residuals,"RSE" = RSE, "Rsquared" = Rsquare, "RsquaredAdj" = RsquareAdj, "Fstat" = Fstat, "DF" = df, "pval" = pval, "coefficients" = coef)))
}
linear.model(cars$speed~cars$dist)
summary(lm(cars$speed~cars$dist))
linear.model(cars$speed~cars$dist+I(cars$dist^2))
summary(lm(cars$speed~cars$dist+I(cars$dist^2)))
linear.model(cars$speed~cars$dist+I(cars$dist^2)+I(cars$dist*cars$dist*cars$dist))
summary(lm(cars$speed~cars$dist+I(cars$dist^2)+I(cars$dist*cars$dist*cars$dist)))
library(LemilExamST522)
library(LemilExamST522)
library(roxygen2)
roxygen2::roxygenise()
