if(!is.logical(plot) || length(plot)>1){
stop("'plot' must be logical non-vector.")
}
if(!is.numeric(df) || df!= round(df) || df < 1 || length(df)>1 ){
stop(" df must be a natural number")
}
if(!is.vector(x) ){
stop(" x must be a numerical vector")
}
#---------------------------End Error Handler----------------------------#
lx <- length(x)
storage <- matrix(rep(0,lx*n), nrow = lx)
Pr <- rep(0,length(x))
for(k in 1:lx){
for(i in 1:n){
storage[k,i]<- sum(rnorm(df)^2)
}
}
for(j in 1: lx){
Pr[j] <- length(storage[j,][storage[j,] > x[j]])/n
}
if(plot==TRUE){
par(mfrow=c(2,1))
plot(density(storage[1,]))
plot(ecdf(storage[1,]))
}
return(Pr)
}
chi.probability(5, 5, 1000, TRUE)
chi.probability <- function(x,df = 1,n = 100){
#Syntax Processing
#============================================================
if(is.matrix(x) || is.list(x) || length(x)!=1){ #Check that x is a single value
stop("'x' has to be an integer; length=1, non-list, non-matrix")
} else if(!is.numeric(x)){ #checks if x is a number
stop("'x' has to be a number")
}
if(is.matrix(df) || is.list(df) || length(df)!=1){ #Check that df is a single value
stop("'df' has to be an integer; length=1, non-list, non-matrix")
} else if(!is.numeric(df)){ #checks if df is a number
stop("'df' has to be a positive integer")
} else if(df != abs(round(df))){ #checks if df is a positive integer
stop("'df' has to be a positive integer")
}
if(is.matrix(n) || is.list(n) || length(n)!=1){ #Check that n is a single value
stop("'n' has to be an integer; length=1, non-list, non-matrix")
} else if(!is.numeric(n)){ #checks if n is a number
stop("'n' has to be a positive integer")
} else if(n != abs(round(n))){ #checks if n is a positive integer
stop("'n' has to be a positive integer")
}
#------------------------------------------------------------
for (i in 1:length(x)){
variables <- rnorm(n*df) #Generate the random variables for the matrix
matrixNumbers <- matrix(variables, c(n,df)) #Generate the matrix
chi <- numeric() #initialise chi
for(i in 1:n){ #Sum up each row in the matrix to get the chi values.
chi[i] <- sum(matrixNumbers[i,]^2)
}
cdf <- ecdf(chi) #Use the empirical cumulative distribution function
a <- cdf(x) #Now we look at the specific value for x, i.e. P(chi^2 < x)
return(1-a) #Return the probability 1-P(chi^2 < x) = P(chi^2 > x)
}
}
chi.probability(5, 5, 1000, TRUE)
chi.probability(5, 5, 1000)
chi.probability(5, 5, 1000)
chi.probability(5, 5, 1000)
chi.probability <- function(x, df = 5, n = 1000,  plot = FALSE){
#----------------------------Error Handler-------------------------------#
if(!is.numeric(n) || n!= round(n) || n < 1 || length(n)>1){
stop("'n' must be a natural number")
}
if(!is.logical(plot) || length(plot)>1){
stop("'plot' must be logical non-vector.")
}
if(!is.numeric(df) || df!= round(df) || df < 1 || length(df)>1 ){
stop(" df must be a natural number")
}
if(!is.vector(x) ){
stop(" x must be a numerical vector")
}
#---------------------------End Error Handler----------------------------#
lx <- length(x)
storage <- matrix(rep(0,lx*n), nrow = lx)
Pr <- rep(0,length(x))
for(k in 1:lx){
for(i in 1:n){
storage[k,i]<- sum(rnorm(df)^2)
}
}
for(j in 1: lx){
Pr[j] <- length(storage[j,][storage[j,] > x[j]])/n
}
if(plot==TRUE){
par(mfrow=c(2,1))
plot(density(storage[1,]))
plot(ecdf(storage[1,]))
}
return(Pr)
}
chi.probability(c(5,4), 5, 1000)
storage <- matrix(rep(0,2*10),nrow=lx)
storage <- matrix(rep(0,2*10),nrow=1)
storage
storage <- matrix(rep(0,2*10),nrow=2)
storage
storage[1,] <- sum(rnorm(5)^2)
storage
storage <- sum(rnorm(5)^2)
storage
storage <- matrix(rep(0,2*10),nrow=2)
storage[,] <- sum(rnorm(5)^2)
storage
chi.probability <- function(x, df = 5, n = 1000,  plot = FALSE){
#------------------------------------Error Handler:--------------------------------------#
# ---------------------------------------------------------------------------------------#
# 'n' and 'df' must be numeric, natural number greater than 1.                           #
# 'x' must be a numerical vector.                                                        #
# 'plot' must be a boolean value.                                                        #
#----------------------------------------------------------------------------------------#
if(!is.numeric(n) || n!= round(n) || n < 1 || length(n)>1){ #Check that n is a single natural number
stop("'n' must be a natural number")
}
if(!is.logical(plot) || length(plot)>1){ #Check that plot is a single boolean value
stop("'plot' must be logical non-vector.")
}
if(!is.numeric(df) || df!= round(df) || df < 1 || length(df)>1 ){ #Check that df is a single natural number
stop(" df must be a natural number")
}
if(is.matrix(x) || is.list(x) || !is.numeric(x)){ #Check that x is a vector of numbers(can be any length)
stop("'x' has to be an integer; non-list, non-matrix")
}
#---------------------------------------End Error Handler---------------------------------#
lx <- length(x) #Save the length of x for later
storage <- matrix(rep(0,lx*n), nrow = lx) #Generate a matrix so rows are used for multiple different chi probabilities(if x is longer than 1. Defensive)
Pr <- rep(0,length(x)) #Create Pr to save results in.
for(k in 1:lx){ #For every different x, we create values for Pr.
for(i in 1:n){ #We want n numbers for each different x.
storage[k,i]<- sum(rnorm(df)^2) #Chi values
}
}
for(j in 1: lx){ #For every different x, we create a different P-value
Pr[j] <- length(storage[j,][storage[j,] > x[j]])/n #We get P(chi^2 > x)
}
if(plot==TRUE){ #If user wants, we can plot the density function and the empirical cumulative distribution function
par(mfrow=c(2,1)) #Makes space for 2 graphs
plot(density(storage[1,]), main = "Density function") #Plots density function
plot(ecdf(storage[1,]))
}
return(Pr)
}
chi.probability(c(5,4), 5, 1000, TRUE)
chi.probability <- function(x, df = 5, n = 1000,  plot = FALSE){
#------------------------------------Error Handler:--------------------------------------#
# ---------------------------------------------------------------------------------------#
# 'n' and 'df' must be numeric, natural number greater than 1.                           #
# 'x' must be a numerical vector.                                                        #
# 'plot' must be a boolean value.                                                        #
#----------------------------------------------------------------------------------------#
if(!is.numeric(n) || n!= round(n) || n < 1 || length(n)>1){ #Check that n is a single natural number
stop("'n' must be a natural number")
}
if(!is.logical(plot) || length(plot)>1){ #Check that plot is a single boolean value
stop("'plot' must be logical non-vector.")
}
if(!is.numeric(df) || df!= round(df) || df < 1 || length(df)>1 ){ #Check that df is a single natural number
stop(" df must be a natural number")
}
if(is.matrix(x) || is.list(x) || !is.numeric(x)){ #Check that x is a vector of numbers(can be any length)
stop("'x' has to be an integer; non-list, non-matrix")
}
#---------------------------------------End Error Handler---------------------------------#
lx <- length(x) #Save the length of x for later
storage <- matrix(rep(0,lx*n), nrow = lx) #Generate a matrix so rows are used for multiple different chi probabilities(if x is longer than 1. Defensive)
Pr <- rep(0,length(x)) #Create Pr to save results in.
for(k in 1:lx){ #For every different x, we create values for Pr.
for(i in 1:n){ #We want n numbers for each different x.
storage[k,i]<- sum(rnorm(df)^2) #Chi values
}
}
for(j in 1: lx){ #For every different x, we create a different P-value
Pr[j] <- length(storage[j,][storage[j,] > x[j]])/n #We get P(chi^2 > x)
}
if(plot==TRUE){ #If user wants, we can plot the density function and the empirical cumulative distribution function
par(mfrow=c(2,lx)) #Makes space for 2 graphs for each x.
for(i in 1:lx){
plot(density(storage[i,]), main = "Density function") #Plots density function
}
for(i in 1:lx){
plot(ecdf(storage[i,]))
}
}
return(Pr)
}
chi.probability(c(5,4), 5, 1000, TRUE)
chi.probability(c(5,4), 5, 1000, TRUE)
chi.probability(c(5,4,3), 5, 1000, TRUE)
plot(1,2)
chi.probability <- function(x, df = 5, n = 1000,  plot = FALSE){
#------------------------------------Error Handler:--------------------------------------#
# ---------------------------------------------------------------------------------------#
# 'n' and 'df' must be numeric, natural number greater than 1.                           #
# 'x' must be a numerical vector.                                                        #
# 'plot' must be a boolean value.                                                        #
#----------------------------------------------------------------------------------------#
if(!is.numeric(n) || n!= round(n) || n < 1 || length(n)>1){ #Check that n is a single natural number
stop("'n' must be a natural number")
}
if(!is.logical(plot) || length(plot)>1){ #Check that plot is a single boolean value
stop("'plot' must be logical non-vector.")
}
if(!is.numeric(df) || df!= round(df) || df < 1 || length(df)>1 ){ #Check that df is a single natural number
stop(" df must be a natural number")
}
if(is.matrix(x) || is.list(x) || !is.numeric(x)){ #Check that x is a vector of numbers(can be any length)
stop("'x' has to be an integer; non-list, non-matrix")
}
#---------------------------------------End Error Handler---------------------------------#
lx <- length(x) #Save the length of x for later
storage <- matrix(rep(0,lx*n), nrow = lx) #Generate a matrix so rows are used for multiple different chi probabilities(if x is longer than 1. Defensive)
Pr <- rep(0,length(x)) #Create Pr to save results in.
for(k in 1:lx){ #For every different x, we create values for Pr.
for(i in 1:n){ #We want n numbers for each different x.
storage[k,i]<- sum(rnorm(df)^2) #Chi values
}
}
for(j in 1: lx){ #For every different x, we create a different P-value
Pr[j] <- length(storage[j,][storage[j,] > x[j]])/n #We get P(chi^2 > x)
}
if(plot==TRUE){ #If user wants, we can plot the density function and the empirical cumulative distribution function
par(mfrow=c(2,lx)) #Makes space for 2 graphs for each x.
for(i in 1:lx){
plot(density(storage[i,]), main = "Density function") #Plots density function
}
for(i in 1:lx){
plot(ecdf(storage[i,]))
}
par(mfrow=c(1,1))
}
return(Pr)
}
chi.probability(c(5,4,3), 5, 1000, TRUE)
plot(1,2)
chi.probability <- function(x, df = 5, n = 1000,  plot = FALSE){
#------------------------------------Error Handler:--------------------------------------#
# ---------------------------------------------------------------------------------------#
# 'n' and 'df' must be numeric, natural number greater than 1.                           #
# 'x' must be a numerical vector.                                                        #
# 'plot' must be a boolean value.                                                        #
#----------------------------------------------------------------------------------------#
if(!is.numeric(n) || n!= round(n) || n < 1 || length(n)>1){ #Check that n is a single natural number
stop("'n' must be a natural number")
}
if(!is.logical(plot) || length(plot)>1){ #Check that plot is a single boolean value
stop("'plot' must be logical non-vector.")
}
if(!is.numeric(df) || df!= round(df) || df < 1 || length(df)>1 ){ #Check that df is a single natural number
stop(" df must be a natural number")
}
if(is.matrix(x) || is.list(x) || !is.numeric(x)){ #Check that x is a vector of numbers(can be any length)
stop("'x' has to be an integer; non-list, non-matrix")
}
#---------------------------------------End Error Handler---------------------------------#
lx <- length(x) #Save the length of x for later
storage <- matrix(rep(0,lx*n), nrow = lx) #Generate a matrix so rows are used for multiple different chi probabilities(if x is longer than 1. Defensive)
Pr <- rep(0,length(x)) #Create Pr to save results in.
for(k in 1:lx){ #For every different x, we create values for Pr.
for(i in 1:n){ #We want n numbers for each different x.
storage[k,i]<- sum(rnorm(df)^2) #Chi values
}
}
for(j in 1: lx){ #For every different x, we create a different P-value
Pr[j] <- length(storage[j,][storage[j,] > x[j]])/n #We get P(chi^2 > x)
}
if(plot==TRUE){ #If user wants, we can plot the density function and the empirical cumulative distribution function
par(mfrow=c(2,lx)) #Makes space for 2 graphs for each x.
for(i in 1:lx){
plot(density(storage[i,]), xlab = "x", main = "Density function") #Plots density functions
}
for(i in 1:lx){
plot(ecdf(storage[i,]))
}
par(mfrow=c(1,1))
}
return(Pr)
}
chi.probability(c(5,4,3), 5, 1000, TRUE)
chi.probability <- function(x, df = 5, n = 1000,  plot = FALSE){
#------------------------------------Error Handler:--------------------------------------#
# ---------------------------------------------------------------------------------------#
# 'n' and 'df' must be numeric, natural number greater than 1.                           #
# 'x' must be a numerical vector.                                                        #
# 'plot' must be a boolean value.                                                        #
#----------------------------------------------------------------------------------------#
if(!is.numeric(n) || n!= round(n) || n < 1 || length(n)>1){ #Check that n is a single natural number
stop("'n' must be a natural number")
}
if(!is.logical(plot) || length(plot)>1){ #Check that plot is a single boolean value
stop("'plot' must be logical non-vector.")
}
if(!is.numeric(df) || df!= round(df) || df < 1 || length(df)>1 ){ #Check that df is a single natural number
stop(" df must be a natural number")
}
if(is.matrix(x) || is.list(x) || !is.numeric(x)){ #Check that x is a vector of numbers(can be any length)
stop("'x' has to be an integer; non-list, non-matrix")
}
#---------------------------------------End Error Handler---------------------------------#
lx <- length(x) #Save the length of x for later
storage <- matrix(rep(0,lx*n), nrow = lx) #Generate a matrix so rows are used for multiple different chi probabilities(if x is longer than 1. Defensive)
Pr <- rep(0,length(x)) #Create Pr to save results in.
for(k in 1:lx){ #For every different x, we create values for Pr.
for(i in 1:n){ #We want n numbers for each different x.
storage[k,i]<- sum(rnorm(df)^2) #Chi values
}
}
for(j in 1: lx){ #For every different x, we create a different P-value
Pr[j] <- length(storage[j,][storage[j,] > x[j]])/n #We get P(chi^2 > x)
}
if(plot==TRUE){ #If user wants, we can plot the density function and the empirical cumulative distribution function
par(mfrow=c(2,lx)) #Makes space for 2 graphs for each x.
for(i in 1:lx){
plot(density(storage[i,]), xlab = "x", main = "Density function") #Plots density functions
}
for(i in 1:lx){
plot(ecdf(storage[i,]), main = "ECDF")
}
par(mfrow=c(1,1))
}
return(Pr)
}
chi.probability(c(5,4,3), 5, 1000, TRUE)
list(TRUE)
length(list(TRUE))
is.logical(list(TRUE))
is.logical(matrix(TRUE))
matrix(TRUE) == TRUE
if(matrix(TRUE) == TRUE){print("yes")}
chi.gof <- function(x,p){
#Syntax Processing
#============================================================
#First we check if x is a vector of numbers
if(!is.vector(x) || is.matrix(x) || is.list(x) || !is.numeric(x)){
stop("'x' has to be a vector of numbers.(Non list, non matrix)")
}
if(missing(p)){ #If p is not used, probability is uniform
p <- rep((1/length(x)),length(x))
} else if(!is.vector(p) || is.matrix(p) || is.list(p) || !is.numeric(p)){
stop("'p' has to be a vector of numbers.(Non list, non matrix)") #If p exist, check it is a vector of numbers
} else if(length(p) != length(x)){
stop("'p' and 'x' has to be of the same length")
}
if(sum(p) != 1){ #Warn the user if the total probability does not equal to 1.
warning("Sum of p is not equal to 1, this may cause incorrect calculations.")
}
checker <- p<0
checker2 <- x<0
if(length(checker[checker == TRUE]) > 0){ #Warn the user if they added negative probabilities
warning("p contains negative values, this may cause incorrect calculations.")
}
if(length(checker2[checker2 == TRUE]) > 0){ #Warn the user if they added negative values to x
warning("x contains negative values, this may cause incorrect calculations.")
}
#------------------------------------------------------------
k <- length(x) #Calculating chi.probability requires the degrees of freedom
n <- sum(x) #We need to know how many there are in total for Pearson's Chi-squared statistic
return(sum(((x - n*p)^2)/(n*p))) #Formula to calculate Pearson's Chi-squared statistic
}
chi.test <- function(x,p){
#------------------------------------Error Handler:--------------------------------------#
# ---------------------------------------------------------------------------------------#
# 'x' must be a vector of positive numbers                                               #
# 'p' must be a vector of probabilities. If not chosen, program decides uniform          #
#----------------------------------------------------------------------------------------#
#First we check if x is a vector of numbers
if(!is.vector(x) || is.matrix(x) || is.list(x) || !is.numeric(x)){
stop("'x' has to be a vector of numbers.(Non list, non matrix)")
}
if(missing(p)){ #If p is not used, probability is uniform
p <- rep((1/length(x)),length(x))
} else if(!is.vector(p) || is.matrix(p) || is.list(p) || !is.numeric(p)){
stop("'p' has to be a vector of numbers.(Non list, non matrix)") #If p exist, check it is a vector of numbers
} else if(length(p) != length(x)){
stop("'p' and 'x' has to be of the same length")
}
if(sum(p) != 1){ #Warn the user if the total probability does not equal to 1.
warning("Sum of p is not equal to 1, this may cause incorrect calculations.")
}
if(length(length(p[p<0])>0)){ #Warn the user if they added negative probabilities
stop("p contains negative values, this will cause incorrect calculations.")
}
if(length(length(x[x<0])>0)){ #Warn the user if they added negative values to x
stop("x contains negative values, this will cause incorrect calculations.")
}
#---------------------------------------End Error Handler---------------------------------#
n <- sum(x) #We need to know how many there are in total for Pearson's Chi-squared statistic
return(sum(((x - n*p)^2)/(n*p))) #Formula to calculate Pearson's Chi-squared statistic
}
chi.test(c(1,2,3),c(0.25,0.6,0.15))
chi.test <- function(x,p){
#------------------------------------Error Handler:--------------------------------------#
# ---------------------------------------------------------------------------------------#
# 'x' must be a vector of positive numbers                                               #
# 'p' must be a vector of probabilities. If not chosen, program decides uniform          #
#----------------------------------------------------------------------------------------#
#First we check if x is a vector of numbers
if(!is.vector(x) || is.matrix(x) || is.list(x) || !is.numeric(x)){
stop("'x' has to be a vector of numbers.(Non list, non matrix)")
}
if(missing(p)){ #If p is not used, probability is uniform
p <- rep((1/length(x)),length(x))
} else if(!is.vector(p) || is.matrix(p) || is.list(p) || !is.numeric(p)){
stop("'p' has to be a vector of numbers.(Non list, non matrix)") #If p exist, check it is a vector of numbers
} else if(length(p) != length(x)){
stop("'p' and 'x' has to be of the same length")
}
if(sum(p) != 1){ #Warn the user if the total probability does not equal to 1.
warning("Sum of p is not equal to 1, this may cause incorrect calculations.")
}
if(length(length(p[p<0]))>0){ #Warn the user if they added negative probabilities
stop("p contains negative values, this will cause incorrect calculations.")
}
if(length(length(x[x<0]))>0){ #Warn the user if they added negative values to x
stop("x contains negative values, this will cause incorrect calculations.")
}
#---------------------------------------End Error Handler---------------------------------#
n <- sum(x) #We need to know how many there are in total for Pearson's Chi-squared statistic
return(sum(((x - n*p)^2)/(n*p))) #Formula to calculate Pearson's Chi-squared statistic
}
chi.test(c(1,2,3),c(0.25,0.6,0.15))
x <- c(1,2,3)
p <- c(0.25,0.6,0.15)
p[p<0]
length(p[p<0])
length(length(p[p<0]))>0
length(length(p[p<0]))
length(p[p<0])>0
chi.test <- function(x,p){
#------------------------------------Error Handler:--------------------------------------#
# ---------------------------------------------------------------------------------------#
# 'x' must be a vector of positive numbers                                               #
# 'p' must be a vector of probabilities. If not chosen, program decides uniform          #
#----------------------------------------------------------------------------------------#
#First we check if x is a vector of numbers
if(!is.vector(x) || is.matrix(x) || is.list(x) || !is.numeric(x)){
stop("'x' has to be a vector of numbers.(Non list, non matrix)")
}
if(missing(p)){ #If p is not used, probability is uniform
p <- rep((1/length(x)),length(x))
} else if(!is.vector(p) || is.matrix(p) || is.list(p) || !is.numeric(p)){
stop("'p' has to be a vector of numbers.(Non list, non matrix)") #If p exist, check it is a vector of numbers
} else if(length(p) != length(x)){
stop("'p' and 'x' has to be of the same length")
}
if(sum(p) != 1){ #Warn the user if the total probability does not equal to 1.
warning("Sum of p is not equal to 1, this may cause incorrect calculations.")
}
if(length(p[p<0])>0){ #Warn the user if they added negative probabilities
stop("p contains negative values, this will cause incorrect calculations.")
}
if(length(x[x<0])>0){ #Warn the user if they added negative values to x
stop("x contains negative values, this will cause incorrect calculations.")
}
#---------------------------------------End Error Handler---------------------------------#
n <- sum(x) #We need to know how many there are in total for Pearson's Chi-squared statistic
return(sum(((x - n*p)^2)/(n*p))) #Formula to calculate Pearson's Chi-squared statistic
}
chi.test(c(1,2,3),c(0.25,0.6,0.15))
chi.test(c(1,2,3),c(0.25,0.6,0.15))
chi.test(c(1,2,3),c(0.25,0.6,0.15))
chi.test(c(1,2,3),c(0.25,0.6,0.15))
chi.probability <- function(x, df = 5, n = 1000,  plot = FALSE){
#------------------------------------Error Handler:--------------------------------------#
# ---------------------------------------------------------------------------------------#
# 'n' and 'df' must be numeric, natural number greater than 1.                           #
# 'x' must be a numerical vector.                                                        #
#----------------------------------------------------------------------------------------#
if(is.matrix(n) || is.list(n) || length(n)!=1){ #Check that n is a single value
stop("'n' has to be a positive integer; length=1, non-list, non-matrix")
} else if(!is.numeric(n)){ #checks if n is a number
stop("'n' has to be a positive integer")
} else if(n < 1 || n != round(n)){ #checks if n is a natural number
stop("'n' has to be a positive integer")
}
if(is.matrix(df) || is.list(df) || length(df)!=1){ #Check that df is a single value
stop("'df' has to be an integer; length=1, non-list, non-matrix")
} else if(!is.numeric(df)){ #checks if df is a number
stop("'df' has to be a positive integer")
} else if(df < 1){ #checks if df is a positive integer
stop("'df' has to be a positive integer")
}
if(is.matrix(x) || is.list(x) || !is.numeric(x)){ #Check that x is a vector of numbers(can be any length)
stop("'x' has to be an integer; non-list, non-matrix")
}
#---------------------------------------End Error Handler---------------------------------#
lx <- length(x) #Save the length of x for later
storage <- matrix(rep(0,lx*n), nrow = lx) #Generate a matrix so rows are used for multiple different chi probabilities(if x is longer than 1. Defensive)
Pr <- rep(0,length(x)) #Create Pr to save results in.
for(k in 1:lx){ #For every different x, we create values for Pr.
for(i in 1:n){ #We want n numbers for each different x.
storage[k,i]<- sum(rnorm(df)^2) #Chi values
}
}
for(j in 1: lx){ #For every different x, we create a different P-value
Pr[j] <- length(storage[j,][storage[j,] > x[j]])/n #We get P(chi^2 > x)
}
return(Pr) #Returns the p-value
}
chi.test(c(1,2,3),c(0.25,0.6,0.15))
chi.probability(5.777778,5,1000)
library(LemilExamST522)
roxygen2::roxygenise()
