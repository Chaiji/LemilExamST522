if(!missing(d)){
if(is.list(d) || !is.numeric(d) || is.matrix(d) || !is.vector(d)   ){
stop(" The given point(s) 'd' must be a number or a vector of numbers.")
}
}
if(!missing(h)){
if(is.list(h) || !is.numeric(h) || is.matrix(h) || length(h) != 1 || h < 0){
stop(" The given bandwidth 'h' must be a single positive number.")
}
}
if(method != "naive" && method != "kernel"){
stop("The given argument 'method' has to be either 'naive' or 'kernel'")
}
#---------------------------------------End Error Handler--------------------------------------#
if(missing(d)){
d <- c(min(x),quantile(x,0.25,names=FALSE),median(x),mean(x),quantile(x,0.75,names=FALSE),max(x))
tableplease <- TRUE #If user did not choose d, we use a table. This boolean value decides that.
} else{
tableplease <- FALSE #If user chooses d, output is exactly the result of evaluating d.
}
n <- length(x) #n is the amount of values in x. This information is needed regardless of estimator
if(method == "naive"){ #Naive estimator
if(missing(h)){ #If h not given, but method is naive.
h <- diff(range(x)/(1+log2(n))) #h is chosen based on Sturges method of choosing bandwidth. Ceiling the denominator??????
}
w <- matrix(rep(0,length(x)*length(d)),nrow=length(d),ncol=length(x)) #Allows calculating multiple values for d simultaneously using a matrix
for (j in 1:length(d)){ #We need to check a row of values for every value in d.
for(i in 1:length(x)){ #We need to check every x.
if(abs((d[j] - x[i])/h) < 1){ #Easier to calculate each w beforehand and then sum them later
w[j,i] <- 1/2
}
}
}
for(i in 1:length(d)){
f[i] <- (1/(n*h)) * sum(w[i,]) #f are calculated
}
} else if(method =="kernel"){
if(missing(h)){ #If h not given, but method is kernel
h <- ((4*sd(x)^5)/(3*n))^(1/5) #h is chosen based on Silvermans suggestion for choosing bandwidth for Gaussian functions. Ceiling somewhere??????
}
K <- matrix(rep(0,length(x)*length(d)),nrow=length(d),ncol=length(x))
for(j in 1:length(d)){
for(i in 1:length(x)){ #Easier to calculate each K beforehand and then sum them later
u <- (d[j] - x[i])/h
K[j,i] <- (1/(sqrt(2*pi)))*exp(-(1/2)*u^2)
}
}
for(i in 1:length(d)){ #f are calculated
f[i] <- (1/(n*h))*sum(K[i,])
}
}
if(tableplease == TRUE){ #If user did not choose d, return a table of information.
fr <- data.frame(x=d, y=f, row.names=c("Min.","1st Qu.","Median","Mean","3rd Qu.","Max."))
return(list("BandWidth" = h, "Data" = fr))
} else{
return(f)
}
}
density.estimator(cars$speed)
density.estimator <- function(x,d,h,method="naive"){
#d missing -> check min, 1st quantile, median, mean, 3rd quantile, max
#------------------------------------Error Handler:--------------------------------------------#
# ---------------------------------------------------------------------------------------------#
# x is a vector of numbers                                                                     #
# d is a numeric value, can be a vector                                                        #
# h is a positive numeric value, if no input, use Struges or Silvermans depending on method    #
# method is a string that either contains "naive" or "kernel", defaults to "naive"             #
#----------------------------------------------------------------------------------------------#
if(is.list(x) || !is.numeric(x) || is.matrix(x) || !is.vector(x)   ){
stop(" The given data 'x' must be a numerical vector.")
}
if(!missing(d)){
if(is.list(d) || !is.numeric(d) || is.matrix(d) || !is.vector(d)   ){
stop(" The given point(s) 'd' must be a number or a vector of numbers.")
}
}
if(!missing(h)){
if(is.list(h) || !is.numeric(h) || is.matrix(h) || length(h) != 1 || h < 0){
stop(" The given bandwidth 'h' must be a single positive number.")
}
}
if(method != "naive" && method != "kernel"){
stop("The given argument 'method' has to be either 'naive' or 'kernel'")
}
#---------------------------------------End Error Handler--------------------------------------#
if(missing(d)){
d <- c(min(x),quantile(x,0.25,names=FALSE),median(x),mean(x),quantile(x,0.75,names=FALSE),max(x))
tableplease <- TRUE #If user did not choose d, we use a table. This boolean value decides that.
} else{
tableplease <- FALSE #If user chooses d, output is exactly the result of evaluating d.
}
n <- length(x) #n is the amount of values in x. This information is needed regardless of estimator
f <- rep(0,length(d))
if(method == "naive"){ #Naive estimator
if(missing(h)){ #If h not given, but method is naive.
h <- diff(range(x)/(1+log2(n))) #h is chosen based on Sturges method of choosing bandwidth. Ceiling the denominator??????
}
w <- matrix(rep(0,length(x)*length(d)),nrow=length(d),ncol=length(x)) #Allows calculating multiple values for d simultaneously using a matrix
for (j in 1:length(d)){ #We need to check a row of values for every value in d.
for(i in 1:length(x)){ #We need to check every x.
if(abs((d[j] - x[i])/h) < 1){ #Easier to calculate each w beforehand and then sum them later
w[j,i] <- 1/2
}
}
}
for(i in 1:length(d)){
f[i] <- (1/(n*h)) * sum(w[i,]) #f are calculated
}
} else if(method =="kernel"){
if(missing(h)){ #If h not given, but method is kernel
h <- ((4*sd(x)^5)/(3*n))^(1/5) #h is chosen based on Silvermans suggestion for choosing bandwidth for Gaussian functions. Ceiling somewhere??????
}
K <- matrix(rep(0,length(x)*length(d)),nrow=length(d),ncol=length(x))
for(j in 1:length(d)){
for(i in 1:length(x)){ #Easier to calculate each K beforehand and then sum them later
u <- (d[j] - x[i])/h
K[j,i] <- (1/(sqrt(2*pi)))*exp(-(1/2)*u^2)
}
}
for(i in 1:length(d)){ #f are calculated
f[i] <- (1/(n*h))*sum(K[i,])
}
}
if(tableplease == TRUE){ #If user did not choose d, return a table of information.
fr <- data.frame(x=d, y=f, row.names=c("Min.","1st Qu.","Median","Mean","3rd Qu.","Max."))
return(list("BandWidth" = h, "Data" = fr))
} else{
return(f)
}
}
density.estimator(cars$speed)
Rtools
library(roxygen2)
library(Rtools)
library(LemilExamST522)
library(roxygen2)
roxygen2::roxygenise()
library(LemilExamST522)
library(LemilExamST522)
density.estimator <- function(x,d,h,method="naive"){
#d missing -> check min, 1st quantile, median, mean, 3rd quantile, max
#------------------------------------Error Handler:--------------------------------------------#
# ---------------------------------------------------------------------------------------------#
# x is a vector of numbers                                                                     #
# d is a numeric value, can be a vector                                                        #
# h is a positive numeric value, if no input, use Struges or Silvermans depending on method    #
# method is a string that either contains "naive" or "kernel", defaults to "naive"             #
#----------------------------------------------------------------------------------------------#
if(is.list(x) || !is.numeric(x) || is.matrix(x) || !is.vector(x)   ){
stop(" The given data 'x' must be a numerical vector.")
}
if(!missing(d)){
if(is.list(d) || !is.numeric(d) || is.matrix(d) || !is.vector(d)   ){
stop(" The given point(s) 'd' must be a number or a vector of numbers.")
}
}
if(!missing(h)){
if(is.list(h) || !is.numeric(h) || is.matrix(h) || length(h) != 1 || h < 0){
stop(" The given bandwidth 'h' must be a single positive number.")
}
}
if(method != "naive" && method != "kernel"){
stop("The given argument 'method' has to be either 'naive' or 'kernel'")
}
#---------------------------------------End Error Handler--------------------------------------#
if(missing(d)){
d <- c(min(x),quantile(x,0.25,names=FALSE),median(x),mean(x),quantile(x,0.75,names=FALSE),max(x))
tableplease <- TRUE #If user did not choose d, we use a table. This boolean value decides that.
} else{
tableplease <- FALSE #If user chooses d, output is exactly the result of evaluating d.
}
n <- length(x) #n is the amount of values in x. This information is needed regardless of estimator
f <- rep(0,length(d))
if(method == "naive"){ #Naive estimator
if(missing(h)){ #If h not given, but method is naive.
h <- diff(range(x)/(1+log2(n))) #h is chosen based on Sturges method of choosing bandwidth. Ceiling the denominator??????
}
w <- matrix(rep(0,length(x)*length(d)),nrow=length(d),ncol=length(x)) #Allows calculating multiple values for d simultaneously using a matrix
for (j in 1:length(d)){ #We need to check a row of values for every value in d.
for(i in 1:length(x)){ #We need to check every x.
if(abs((d[j] - x[i])/h) < 1){ #Easier to calculate each w beforehand and then sum them later
w[j,i] <- 1/2
}
}
}
for(i in 1:length(d)){
f[i] <- (1/(n*h)) * sum(w[i,]) #f are calculated
}
} else if(method =="kernel"){
if(missing(h)){ #If h not given, but method is kernel
h <- ((4*sd(x)^5)/(3*n))^(1/5) #h is chosen based on Silvermans suggestion for choosing bandwidth for Gaussian functions. Ceiling somewhere??????
}
K <- matrix(rep(0,length(x)*length(d)),nrow=length(d),ncol=length(x))
for(j in 1:length(d)){
for(i in 1:length(x)){ #Easier to calculate each K beforehand and then sum them later
u <- (d[j] - x[i])/h
K[j,i] <- (1/(sqrt(2*pi)))*exp(-(1/2)*u^2)
}
}
for(i in 1:length(d)){ #f are calculated
f[i] <- (1/(n*h))*sum(K[i,])
}
}
if(tableplease == TRUE){ #If user did not choose d, return a table of information.
fr <- data.frame(x=d, y=f, row.names=c("Min.","1st Qu.","Median","Mean","3rd Qu.","Max."))
return(list("BandWidth" = h, "Data" = fr))
} else{
return(f)
}
}
density.estimator(cars$speed)
roxygen2::roxygenise()
library(LemilExamST522)
roxygen2::roxygenise()
library(LemilExamST522)
roxygen2::roxygenise()
from=1
to=500
n=200
help(seq)
seq(1,500,(diff(from,to)/n))
diff(from,to)/n
help(diff)
diff(c(from,to))/n
diff(c(from,to)
)
diff(c(from,to))/n
seq(1,500,(diff(c(from,to))/200))
diff(c(-5,5))
help(plot)
dens.plot <- function(x,n=500,method="naive",from,to){
#------------------------------------Error Handler:--------------------------------------------#
# ---------------------------------------------------------------------------------------------#
# x is a vector of numbers                                                                     #
# n is the number of points to be used for plotting the density function. default is 500       #
# method is a string that either contains "naive" or "kernel", defaults to "naive"             #
# from is a number for where to start plot. If none chosen, calculates based on sd(x)          #
# to is a number for where to end plot. If none chosen, calculates based on sd(x)              #
#----------------------------------------------------------------------------------------------#
if(is.list(x) || !is.numeric(x) || is.matrix(x) || !is.vector(x)   ){
stop(" The given data 'x' must be a numerical vector.")
}
if(is.matrix(n) || is.list(n) || length(n)!=1){ #Check that n is a single value
stop("'n' has to be a positive integer; length=1, non-list, non-matrix")
} else if(!is.numeric(n)){ #checks if n is a number
stop("'n' has to be a positive integer")
} else if(n < 1 || n != round(n)){ #checks if n is a natural number
stop("'n' has to be a positive integer")
}
if(method != "naive" && method != "kernel"){
stop("The given argument 'method' has to be either 'naive' or 'kernel'")
}
if(!missing(from)){
if(is.matrix(from) || is.list(from) || length(from)!=1){ #Check that n is a single value
stop("'from' has to be a number; length=1, non-list, non-matrix")
} else if(!is.numeric(n)){ #checks if n is a number
stop("'from' has to be a number")
}
}
if(!missing(to)){
if(is.matrix(to) || is.list(to) || length(to)!=1){ #Check that n is a single value
stop("'to' has to be a number; length=1, non-list, non-matrix")
} else if(!is.numeric(to)){ #checks if n is a number
stop("'to' has to be a number")
}
}
#---------------------------------------End Error Handler--------------------------------------#
if(missing(from)){ #From is chosen as minimum of x, minus standard deviation/3
from <- min(x) - sd(x)/3
}
if(missing(to)){ #To is chosen as maxmimum of x, plus standard deviation/3
to <- max(x) + sd(x)/3
}
if(from > to){ #If somehow from is greater than to, flip them. Defensive measure!
temp <- to
to <- from
from <- temp
}
intervalX <- seq(from,to,(diff(c(from,to))/n))
if(method=="naive"){
intervalY <- dens.estimator(x,d=intervalX,method="naive")
plot(intervalX,intervalY, main="Naive estimator", xlab="points", ylab="density")
} else if(method=="kernel"){
intervalY <- dens.estimator(x,d=intervalX,method="kernel")
plot(intervalX,intervalY, main="Gaussian estimator", xlab="points", ylab="density")
}
}
View(density.estimator)
remove(density.estimator)
dens.estimator <- function(x,d,h,method="naive"){
#------------------------------------Error Handler:--------------------------------------------#
# ---------------------------------------------------------------------------------------------#
# x is a vector of numbers                                                                     #
# d is a numeric value, can be a vector                                                        #
# h is a positive numeric value, if no input, use Struges or Silvermans depending on method    #
# method is a string that either contains "naive" or "kernel", defaults to "naive"             #
#----------------------------------------------------------------------------------------------#
if(is.list(x) || !is.numeric(x) || is.matrix(x) || !is.vector(x)   ){
stop(" The given data 'x' must be a numerical vector.")
}
if(!missing(d)){
if(is.list(d) || !is.numeric(d) || is.matrix(d) || !is.vector(d)   ){
stop(" The given point(s) 'd' must be a number or a vector of numbers.")
}
}
if(!missing(h)){
if(is.list(h) || !is.numeric(h) || is.matrix(h) || length(h) != 1 || h < 0){
stop(" The given bandwidth 'h' must be a single positive number.")
}
}
if(method != "naive" && method != "kernel"){
stop("The given argument 'method' has to be either 'naive' or 'kernel'")
}
#---------------------------------------End Error Handler--------------------------------------#
if(missing(d)){
d <- c(min(x),quantile(x,0.25,names=FALSE),median(x),mean(x),quantile(x,0.75,names=FALSE),max(x))
tableplease <- TRUE #If user did not choose d, we use a table. This boolean value decides that.
} else{
tableplease <- FALSE #If user chooses d, output is exactly the result of evaluating d.
}
n <- length(x) #n is the amount of values in x. This information is needed regardless of estimator
f <- rep(0,length(d))
if(method == "naive"){ #Naive estimator
if(missing(h)){ #If h not given, but method is naive.
h <- diff(range(x)/(1+log2(n))) #h is chosen based on Sturges method of choosing bandwidth. Ceiling the denominator??????
}
w <- matrix(rep(0,length(x)*length(d)),nrow=length(d),ncol=length(x)) #Allows calculating multiple values for d simultaneously using a matrix
for (j in 1:length(d)){ #We need to check a row of values for every value in d.
for(i in 1:length(x)){ #We need to check every x.
if(abs((d[j] - x[i])/h) < 1){ #Easier to calculate each w beforehand and then sum them later
w[j,i] <- 1/2
}
}
}
for(i in 1:length(d)){
f[i] <- (1/(n*h)) * sum(w[i,]) #f are calculated
}
} else if(method =="kernel"){
if(missing(h)){ #If h not given, but method is kernel
h <- ((4*sd(x)^5)/(3*n))^(1/5) #h is chosen based on Silvermans suggestion for choosing bandwidth for Gaussian functions. Ceiling somewhere??????
}
K <- matrix(rep(0,length(x)*length(d)),nrow=length(d),ncol=length(x))
for(j in 1:length(d)){
for(i in 1:length(x)){ #Easier to calculate each K beforehand and then sum them later
u <- (d[j] - x[i])/h
K[j,i] <- (1/(sqrt(2*pi)))*exp(-(1/2)*u^2)
}
}
for(i in 1:length(d)){ #f are calculated
f[i] <- (1/(n*h))*sum(K[i,])
}
}
if(tableplease == TRUE){ #If user did not choose d, return a table of information.
fr <- data.frame(x=d, y=f, row.names=c("Min.","1st Qu.","Median","Mean","3rd Qu.","Max."))
return(list("BandWidth" = h, "Data" = fr))
} else{
return(f)
}
}
dens.plot(cars$speed)
dens.plot <- function(x,n=500,method="naive",from,to){
#------------------------------------Error Handler:--------------------------------------------#
# ---------------------------------------------------------------------------------------------#
# x is a vector of numbers                                                                     #
# n is the number of points to be used for plotting the density function. default is 500       #
# method is a string that either contains "naive" or "kernel", defaults to "naive"             #
# from is a number for where to start plot. If none chosen, calculates based on sd(x)          #
# to is a number for where to end plot. If none chosen, calculates based on sd(x)              #
#----------------------------------------------------------------------------------------------#
if(is.list(x) || !is.numeric(x) || is.matrix(x) || !is.vector(x)   ){
stop(" The given data 'x' must be a numerical vector.")
}
if(is.matrix(n) || is.list(n) || length(n)!=1){ #Check that n is a single value
stop("'n' has to be a positive integer; length=1, non-list, non-matrix")
} else if(!is.numeric(n)){ #checks if n is a number
stop("'n' has to be a positive integer")
} else if(n < 1 || n != round(n)){ #checks if n is a natural number
stop("'n' has to be a positive integer")
}
if(method != "naive" && method != "kernel"){
stop("The given argument 'method' has to be either 'naive' or 'kernel'")
}
if(!missing(from)){
if(is.matrix(from) || is.list(from) || length(from)!=1){ #Check that n is a single value
stop("'from' has to be a number; length=1, non-list, non-matrix")
} else if(!is.numeric(n)){ #checks if n is a number
stop("'from' has to be a number")
}
}
if(!missing(to)){
if(is.matrix(to) || is.list(to) || length(to)!=1){ #Check that n is a single value
stop("'to' has to be a number; length=1, non-list, non-matrix")
} else if(!is.numeric(to)){ #checks if n is a number
stop("'to' has to be a number")
}
}
#---------------------------------------End Error Handler--------------------------------------#
if(missing(from)){ #From is chosen as minimum of x, minus standard deviation/3
from <- min(x) - sd(x)/3
}
if(missing(to)){ #To is chosen as maxmimum of x, plus standard deviation/3
to <- max(x) + sd(x)/3
}
if(from > to){ #If somehow from is greater than to, flip them. Defensive measure!
temp <- to
to <- from
from <- temp
}
intervalX <- seq(from,to,(diff(c(from,to))/n))
if(method=="naive"){
intervalY <- dens.estimator(x,d=intervalX,method="naive")
plot(intervalX,intervalY, main="Naive estimator", xlab="points", ylab="density", type="l")
} else if(method=="kernel"){
intervalY <- dens.estimator(x,d=intervalX,method="kernel")
plot(intervalX,intervalY, main="Gaussian estimator", xlab="points", ylab="density", type="l")
}
}
dens.plot(cars$speed)
dens.plot(cars$speed,n=1000)
dens.plot(cars$speed,n=10000)
plot(density(cars$speed))
dens.plot(cars$speed,n=10000)
par(mfrow=c(2,1))
plot(density(cars$speed))
dens.plot(cars$speed,n=10000)
density(cars$speed)
a <- density(cars$speed)
a
a$y
dens.plot <- function(x,n=500,method="naive",from,to){
#------------------------------------Error Handler:--------------------------------------------#
# ---------------------------------------------------------------------------------------------#
# x is a vector of numbers                                                                     #
# n is the number of points to be used for plotting the density function. default is 500       #
# method is a string that either contains "naive" or "kernel", defaults to "naive"             #
# from is a number for where to start plot. If none chosen, calculates based on sd(x)          #
# to is a number for where to end plot. If none chosen, calculates based on sd(x)              #
#----------------------------------------------------------------------------------------------#
if(is.list(x) || !is.numeric(x) || is.matrix(x) || !is.vector(x)   ){
stop(" The given data 'x' must be a numerical vector.")
}
if(is.matrix(n) || is.list(n) || length(n)!=1){ #Check that n is a single value
stop("'n' has to be a positive integer; length=1, non-list, non-matrix")
} else if(!is.numeric(n)){ #checks if n is a number
stop("'n' has to be a positive integer")
} else if(n < 1 || n != round(n)){ #checks if n is a natural number
stop("'n' has to be a positive integer")
}
if(method != "naive" && method != "kernel"){
stop("The given argument 'method' has to be either 'naive' or 'kernel'")
}
if(!missing(from)){
if(is.matrix(from) || is.list(from) || length(from)!=1){ #Check that n is a single value
stop("'from' has to be a number; length=1, non-list, non-matrix")
} else if(!is.numeric(n)){ #checks if n is a number
stop("'from' has to be a number")
}
}
if(!missing(to)){
if(is.matrix(to) || is.list(to) || length(to)!=1){ #Check that n is a single value
stop("'to' has to be a number; length=1, non-list, non-matrix")
} else if(!is.numeric(to)){ #checks if n is a number
stop("'to' has to be a number")
}
}
#---------------------------------------End Error Handler--------------------------------------#
if(missing(from)){ #From is chosen as minimum of x, minus standard deviation/3
from <- min(x) - sd(x)/3
}
if(missing(to)){ #To is chosen as maxmimum of x, plus standard deviation/3
to <- max(x) + sd(x)/3
}
if(from > to){ #If somehow from is greater than to, flip them. Defensive measure!
temp <- to
to <- from
from <- temp
}
intervalX <- seq(from,to,(diff(c(from,to))/n))
if(method=="naive"){
intervalY <- dens.estimator(x,d=intervalX,method="naive")
plot(intervalX,intervalY, main="Naive estimator", xlab="points", ylab="density", type="l")
} else if(method=="kernel"){
intervalY <- dens.estimator(x,d=intervalX,method="kernel")
plot(intervalX,intervalY, main="Gaussian estimator", xlab="points", ylab="density", type="l")
}
print(intervalY)
}
dens.plot(cars$speed,n=10000)
dens.plot(cars$speed,n=512)
plot(density(cars$speed))
dens.plot(cars$speed,n=512)
dens.plot(cars$speed,n=512, method="kernel")
plot(density(cars$speed, kernel="gaussian"))
plot(density(cars$speed, kernel="rectangular"))
dens.plot(cars$speed,n=512, method="naive")
dens.plot(cars$speed,n=512, method="kernel")
plot(density(cars$speed))
plot(density(cars$speed))
dens.plot(cars$speed,n=512, method="kernel")
log5(8)
log(4)/log(2)
log(9)/log(3)
dens.plot(cars$speed,n=512, method="kernel", 5, 10)
dens.plot(cars$speed,n=512, method="kernel")
dens.plot(cars$speed)
library(LemilExamST522)
roxygen2::roxygenise()
set.seed(1)
runif(10)
set.seed(1)
runif(10)
help(rbinom)
